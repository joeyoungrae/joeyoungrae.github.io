[마크다운 문법] (https://heropy.blog/2017/09/30/markdown/)

### 1. 컴퓨터 시스템의 개요

컴퓨터 시스템 : 응용 소프트웨어 + 하드웨어

응용 소프트웨어 <- 전기적 신호 -> 하드웨어

- 하드웨어 : 정보의 전송 통로를 제공 + 정보에 대한 처리가 일어남.

컴퓨터 시스템 <- 상호작용 -> 사용자



컴퓨터 하드웨어

1. 메인보드 : 주요 IC칩들과 메모리 모듈 I/O 인터페이스를 위한 슬롯이 장착되는 기판, 마더보드라고도 부름.

   a. CPU, GPU칩 : 멀티 코어 마이크로 프로세서 및 그래픽 처리 유니트 칩

   b. 주기억장치 모듈 (main memory module) : DDR4, SRAM같은 메모리 칩이 장착된 보드

   c. 확장보드 : 사운드카드와 같이 기능 추가를 위하여 장착된 각종 보드들

2. 전원 공급 장치(power Supply)
3. 광 저장창치(optical storage device) : CD-ROM, DVD, 블루레이 디스크
4. 하드 디스크, SSD 등
5. I/O 장치들 : 키보드, 마우스, 디스플레이 모니터



소프트 웨어란? 정보들이 이동하는 <u>**방향**</u>과 정보 처리의 <u>**종류**</u>를 지정해주고 수행될 <u>**시간**</u>을 지정해주는 명령(command)의 집합

- 다만 소프트웨어는 하드웨어에 의존적이므로, 성능은 근본적으로 하드웨어에 달려 있다.

컴퓨터의 근본적인 기능은 <u>수치 or 논리적 데이터를 적절히 처리하는 것.</u>

하드웨어가 반드시 <u>전자회로만 가능한 것</u>은 아님. 단순한 계산기계로서만 작동하던 초기 시대에는 원형판이나 릴레이와 같은 기계 장치들에 의해 기능들이 수행됨. -> 속도 향상을 위해 점차적으로 전자 장치로 대체됨.



1. 1 컴퓨터의 기본 구조

   - 컴퓨터는 프로그램을 정해진 순서대로 **<u>실행</u>**한다.

     : 필요한 데이터 읽기(read) -> 데이터 처리(processing) -> 결과를 저장(store)

   - CPU(Central Processing Unit),

     - ''프로그램 실행'과 '데이터 처리'를 수행함.

     - 컴퓨터의 특성과 성능에 가장 미치는 구성요소

     - 컴퓨터의 이론적인 처리 속도를 결정지음. (실제 성능은 시스템 내 다른요소들의 영향을 받아서 낮아질 수 있음.)

     - CPU가 처리할 프로그램 코드와 데이터는 기억장치(storage device)에 저장됨. 

       : 기억장치는 주기억장치 / 보조저장장치로 나누어짐.

   - 주기억장치 (**Main memory**)
     - 메인 보드 상에서 CPU와 가까이 위치함.
     - 반도체 기억장치 칩(semiconductor memory chip)들로 이루어져 <u>고속의 읽기 및 쓰기</u>가 가능함.
     - 가격이 높고 면적을 많이 차지하여 <u>저장 용량에 한계가 있다.</u>
     - <u>영구 저장 능력이 없어</u> 프로그램 실행 중에만 일시적으로 사용됨.

   - 보조저장장치 (**Auxiliary Storage device** || **Secondary memory** )
     - 하드디스크, SSD(solid-state-memory)와 같은 <u>영구 저장능력을 가진 기억장치.</u>
     - 저장 밀도가 높고 비트 당 가격이 저렴함.
     - 기계적인 장치가 포함되거나 쓰기 복잡한 반도체 칩들을 이용하여 속도가 느림
     - 보조 저장장치는 <u>CPU가 직접 엑세스 하지 못하고 별도의 제어기를 통해야 함.</u>

   - 입출력 장치 (**I/O device**)

     - 입력장치(input device) 와 출력장치(output device)를 통칭하는 용어

       : 키보드, 디스플레이 모니터 및 프린터 등 다양한 장치들.

     - <u>CPU가 직접 엑세스 하지 못하고 별도의 제어기를 통해야 함</u>  

       : 이런 장치들을 주변장치(peripheral device)라고 부름. (I/O 장치와 보조저장장치 전부 주변장치인 셈.)

1. 2 정보의 표현과 저장

   - 컴퓨터가 받고 처리하는 정보의 종류 : 프로그램 코드(Program Code) & 데이터(Data)

     : 이때 그러한 정보들은 모두 2진수(binary number), 비트들의 조합으로 표현 됨.

   - 언어를 통해 작성됨 -> 컴파일러 -> 기계어 & 기계 코드(Machine conde)

     : 기계코드란, 컴퓨터 하드웨어가 이해할 수 있게 번역된 코드

   - 고급언어와 달리 기계어는 CPU마다 서로 다르다.

     : CPU의 구조마다 그 하드웨어가 이해할 수 있는 언어가 달라지기 때문.

     : 이러한 언어 차이를 해결하기 위해 나타난 게 어셈블리 언어(Assembly language)임.

     ​	: 이걸로 작성된 것은 어셈블리 프로그램(Assembly program)이라 함.

   - 고급-언어 프로그램 -> 어셈블리 프로그램 -> 기계어 프로그램

     - 어셈블리 명령어(**instruction**) : LOAD X, Y / ADD A, Y / STOR Z, A /

     - 니모닉스(**mnemonics**) : 명령어가 지정하는 동작을 나타내는 간략화된 기호

       : 위의 경우 LOAD, ADD, STOR이 이에 해당.

     - 명령어는 <u>CPU가 수행해야 할 동작</u>과 처리해야 할  <u>기억장치 주소 & 레지스터 번호</u>도 구체적으로 지정해줌.
     - 어셈블리 언어로 작성된 프로그램은 어셈블러(Assembler)라는 소프트 웨어가 기계어 프로그램으로 변역함.
     - 어셈블리 언어와 기계어는 거의 1대 1로 대응함.

   - 기계어 프로그램

     - 비트(0과 1)의 조합으로 이루어짐. + 복수 개의 필드로 이루어짐.

     - LOAD A, X -> 001 00101

       : 연산코드 필드(Operation code field)  - 연산을 지정해주는 비트.

       ​	001 : 레지스터 A로 적재하라. 

       : 오퍼랜드 필드(Operand field) : 피연산주소를 지정함.

       ​	00101 : (적재될 데이터가 저장되어 있는 기억장치 주소) 피연산 주소를 가리킴

     - 명령어는 **비트들의 개수**와 **용도** 및 **주소지정 방식**에 따라 다양하게 구성될 수 있다.

       : 2^n만큼 가능함. (이때 n은 해당 필드에 할당받은 비트 수)

     - 명령어 형식(**Instruction format**) : 각 명령어에 들어갈 <u>필드의 종류</u>와 각 필드에 대한 <u>비트 수</u>에 대한 구성

     - 번역된 기계어들은 순차적으로 기억장치에 저장됨.

       

       |    주소     | 데이터 | 사용 용도 |
       | :-: | :--------: | :---: |
       | 0 | 00100101     |  명령어들 |
       | 1 | 10000110     |           |
       | 2 | 01000111     |           |
       | 3 |      |           |
       | 4 |      |           |
       | ... |  - - -   |- - -|
       | X | 00011011     | 데이터들    |
       | Y | 11010111     |           |
       | Z |      |           |

   - 기계어들이 데이터와 함께 기억장치에 저장되어 있는 모습
     
     - 단어(**Word**) : CPU에 의해 <u>한 번에 처리될 수 있는</u> 비트 그룹

   1. 3 시스템의 구성

      1. 3.1 CPU와 기억장치의 접속

         시스템 버스(**System bus**) : CPU와 다른 요소들 간의 정보교환 통로

         : 시스템 버스의 하부버스(sub-bus) : 주소버스 & 데이터 버스 & 제어버스

         - 주소 버스(**address bus**) : CPU가 외부로 발생하는 <u>주소 정보를 전송</u>하는 신호 선들의 집합

           : 각 주소 선은 하나의 주소 비트를 전송하는 데 사용.

           : 전체 주소선들의 개수가 CPU와 접촉될 수 있는 최대 기억장치 용량을 결정해준다.

           : 이때 주소 비트들의 수를 주소 버스 폭(**Width**) 이라 함.

           : CPU에 의해 발생되어 보내지기 때문에 단방향성(uni-directional)

         - 데이터 버스(**Data bus**) : CPU와 기억장치, 혹은 CPU와 I/O장치와의 사이에 <u>데이터를 전송</u>하기 위한 신호선 들의 집합

           : 데이터 버스의 폭은 한번에 전송도리 수 있는 데이터 비트 수를 결정함.

           : 데이터 버스가 32비트인 시스템에서는 CPU가 기억장치로부터 한 번에 32비트씩 읽어올 수 있다.

           : 읽기 & 쓰기 동작을 모두 지원해야 하므로 양뱡향 전송(bi-directional transfer)

         - 제어 버스 (Control bus) : CPU가 시스템 내의 각종 요소들의 <u>동작을 제어</u>하는 데 필요한 선들의 집합

           : 제어 신호 선들의 수는 CPU 혹은 시스템 구성에 따라 달라진다.

           : 가장 기본적인 제어 신호들로는 <u>기억 장치 읽기/쓰기 신호</u> & <u>I/O 읽기 쓰기 신호</u>가 있다.

           : 읽기 & 쓰기 동작을 모두 지원해야 하므로 양뱡향 전송(bi-directional transfer)

         엑세스(**Access**) : CPU가 기억장치에 쓰기 및 읽기를 위해 접근하는 것.

         - 이때 기억장치들은 엑세스되는 방식에 따라 여러가지로 분류될 수 있다.

         CPU가 특정 기억장소로 부터 데이터를 읽고자 한다면?

         - **주소**와 **읽기 신호**를 기억장치로 보내줘야 함.
         - 데이터 저장시에는 **주소**와 쓰기 **신호**를 보내줘야 함.

         : 따라서 CPU 기억 장치 사이에 전송 통로인 주소 버스, 데이터 버스, 제어 신호 선들이 접속되어야 함.

      - 기억장치 쓰기 시간(memory write time)

        : 주소 & 저장할 시스템 버스를 통해 전송함

        : 동시에 쓰기 신호를 활성화함. 

        : 이러한 신호들은 쓰기 동작이 완료될떄까지 유지 되어야 함.

        : CPU가 데이터 보낸 순간부터, 저장이 완료될 때 까지 시간을 말함.

      - 기억장치 읽기 시간

        : 주소를 시스템 버스를 통해 전송함

        : 동시에 읽기 신호를 활성화

        : 컴퓨터가 주소를 읽음 (**주소 해독 시간 비용**) + 데이터가 데이터 버스에 실림(**데이터 인출시 시간이 걸림**). [지연 발생]

        : CPU가 버스 인터페이스 회로(bus interface circuit)를 통하여 읽어드림.

        : CPU가 주소를 발생한 시간부터 읽기 동작이 완료 될때가지 걸리는 시간을 말함.

   1. 3.2 CPU와 I/O장치의 접속

   1. 3.3 전체 시스템의 구성

      - 프로그램 실행 : CPU가 **주기억장치**로부터 프로그램 코드를 읽어서 실행

      - 데이터 저장 : 프로그램 실행 결과로 얻은 데이터를 주기억장치에 저장

      - 데이터 이동 : 디스크, SSD에 저장된 프로그램과 데이터 블록을 주기억장치로 이동

      - 데이터 입력 및 출력 : 사용자가 입력 장치를 이용하여 보내는 명령이나 데이터를 읽음.

        : 처리한 겨로가값이나 기억장치 내용을 출력장치에 출력함

      - 제어 : 프로그램이 순서대로록 혹은 필요에 따라 실행 순서가 변경되도록 조정, 각종 제어 신호들이 발생.

   1. 4 컴퓨터 구조의 발전

   1. 4.1 초기 컴퓨터들의 구조

   1. 4.2 주요 컴퓨터 부품들의 발전 경위

   1. 4.3 컴퓨터 시스템의 분류와 발전 동향

      /* 추후 보충 */



### 02. CPU의 구조와 기능

프로그램 수행

1. 명령어 인출(Instruction fetch) : 기억장치로부터 명령어를 읽어옴
2. 명령어 해독(Instruction decode) : 수행해야 할 동작을 결정하기 위해 명령어를 해독
3. 데이터 인출(Data fetch) : 명령어 실행을 위해 데이터가 필요한 경우 읽어옴.
4. 데이터 처리(Data process) : 데이터에 대한 산술적 논맂거 연산을 수행
5. 데이터 저장(Data store) : 수행한 결과를 저장함.

1, 2번은 반드시 수행. 3번 부터 5번까지는 명령어에 따라 필요한 경우만 수행.



2. 1 CPU의 기본 구조

- 산술 논리 연산 장치 : ALU (Arithemtic and Logical Unit) 

  - 각종 산술 연산들과 논리 연산들을 수행하는 회로로 이루어 진 하드웨어 모듈.
  - 산술 연산은 사칙연산, 논리 연산은 AND, OR, NOT

- 레지스터 세트(Register set)

  - CPU 내부에 위치한 기억장치. 엑세스 속도가 매우 빠름
  - 용량 대비 차지하는 면적이 커서 CPU안에는 적은 수만 포함됨.
  - 특수 목적용 레지스터(지정된 용도로만 사용), 일반 목적용 레지스터들로 구성 됨.

- 제어 유니트(Control unit)

  - 프로그램 코드(명령어)를 해석

  - 실행하기 위한 제어 신호(Control signal)을 순차적으로 발생하는 하드웨어 모듈

  - 명령어 실행에 필요한 각종 정보들의 **전송 통로**와 **방향**을 지정.

  - CPU 내부 요소들과 시스템 구성 요소들의 동작 시간도 결정 (순서가 아닐까?)

  - Microprogramming (복잡도 해소를 위해 제어 유니트의 동작을 소프트 웨어로 처리) vs RISC(하드웨어만으로 명령어를 실행)

    : 최근에는 RISC (Reduced Instruction Set Computer)설계 개념이 많이 사용 됨.

- 데이터 & 제어 신호들의 전용 통로인 CPU 내부 버스(CPu internal bus)도 있다.

  : ALU - resgister간의 데이터 선 & 주소 선

  : 제어 유니트로부터 발생하는 제어 신호들을 전송하는 선

  **: 내부 버스 선들은 외부의 시스템 버스와는 직접 연결되지 않음.** 반드시 버퍼 레지스터, 혹은 인터페이스 회로를 통해 시스템 버스에 접속.

2. 2 명령어 실행

   - 명령어 사이클(Instruction cycle) : 한 개의 명령어를 실행하는 데 필요한 전체 과정

     1. 명령어 인출(Instruction fetch) : CPU가 기억장치로 부터 명령어를 읽어 옴. (인출 사이클)
     2. 명령어 실행(Instruction execution) : 인출된 명령어를 실행함. (실행 사이클)

     : 명령어 사이클은 CPU가 프로그램 실행을 시작한 순간부터 전원을 끄거나 중단 될때까지 반복하여 수행

   - CPU 레지스터 세트 내부.

     - 프로그램 카운터(Program Counter : PC)

       - **다음에 인출될 명령어**의 주소를 가지고 있다.

       - 각 명령어가 인출된 후에는 그 내용이 1(혹은 명령어에 해당하는 주소 단위수 만큼)이 증가함.

         : 해당 메모리에서 명령어를 인출 이후 count + 1

         : 명령어 해독 시도

         : 명령어가 분할 된 경우 다시 읽음.

       - 분기(branch) 명령어가 실행되는 경우 그 목적지 주소로 갱신됨.

     - 누산기(Accumulator : AC) : 데이터를 일시적으로 저장하는 레지스터

       : 이 레지스터의 비트 수는 CPU가 한 번에 연산 처리할 수 있는 데이터 비트의 수, 즉 단어 길이와 같다.

     - 명령어 레지스터 (Instruction Register : IR) : 가장 최근에 인출 된 명령어가 저장되어 있는 레지스터

     - 기억장치 주소 레지스터(Memory Address Register : MAR) : 프로그램 카운터(PC)에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터.

       : PC에서 주소 인출 -> MAR -> 주소버스 식. (주소 버스와 직접 연결되는 레지스터임.)

     - 기억장치 버퍼 레지스터(Memory Buffer Register : MBR) : 데이터 버스와 CPU 내부 버스선 사이에 중간 역할을 하는 버퍼.

       : 기억장치로 부터 읽혀진 데이터가 일시적으로 저장됨. (읽기 신호의 경우)

       : 기억장치에 저장될 데이터가 저장됨. (쓰기 신호인 경우)

       : 기억장치에서 명령어 인출 -> MBR(중간단계 버퍼) -> IR (지금 인출된 명령어)

       : 이후 실행 사이클 시, IR에서 제어 유니트로 보내짐.

       : 기억장치에서 데이터 인출 -> MBR(중간 단계 버퍼) ->  AC

       ​	: 명령어에 따라 연산 수행시, AC -> ALU, ALU에서 계산 -> AC

       : 기억장치로 데이터 저장 MBR -> 기억장치

   2. 2.1 인출 사이클

      - <u>각 명령어 사이클의 시작 단계</u>에서 발생

      - 프로그램 카운터(PC)가 가리키는 (기억장치의)위치에 엑세스 -> 명령어 인출 (PC -> MAR)

      - CPU가 카운터(PC)의 내용을 1 증가.

        : 이렇게 되면 PC는 다음 위치를 가리키고, 다음 인출사이클에서 다음 명령어가 인출되게 됨.

        이렇게 기억장치의 **지정된 위치**로 부터 **명령어를 읽어오는 과정**을 <u>인출 사이클</u>이라 부름.

      마이크로 연산 표현 (micro-operation express)

      t0 : MAR <- PC	{PC -> MAR}

      t1 : MBR <- M[MAR], PC <- PC + 1	{기억장치(M)에 대해 MAR을 통해 접근 후 데이터 적출하여 MBR에 저장. 이후 PC에 1이 증가 됨.}

      t2 : IR <- MBR		{t1에 의해 기억장치에서 읽어와 MBR에 저장된 상태. t2에선 MBR에서 명령어를 뽑아서 IR에 전달함}

      : 기억장치가 몇 바이트 단위로 저장되는지에 따라 그리고 명령어 길이에 따라 PC에 증감 값이 정해짐.

   2. 2.2 실행 사이클

      - 실행 사이클(execution cycle) : CPU가 인출된 명령어를 해독 -> 결과에 따라 필요한 연산은 수행.

        : 이때 수행하는 연산은 다양하지만, 크게 4개로 분류할 수 있다.

        - 데이터 이동 : CPU & 기억장치 혹은 CPU & I/O 장치 간에 데이터를 이동한다.
        - 데이터 처리 : 데이터에 대하여 산술 혹은 논리 연산을 수행
        - 데이터 저장 : 연산결과 데이터 혹은 입력장치로부터 읽어들인 데이터를 기억장치에 저장
        - 프로그램 제어 : 프로그램 실행 순서를 결정.

      - 실행 사이클 수행 과정

        - IR에 저장된 명령어가 있음.

          : 이 명령어는 연산코드 + 오퍼랜드(addr)로 구성 됨.

          ​	: 이때 오퍼랜드는 **<u>데이터가 저장된 기억장치의 주소를 가리킴.</u> ** (이걸 명령어가 사용함.)

        - LOAD 명령어의 마이크로-연산 (**데이터의 이동**)

          t0 : MAR <- IR(addr) {IR에서 엑세스 할 기억장치의 주소를 MAR에 전달}

          t1 : MBR <- M[MAR] {기억장치에서 데이터를 읽어옴.}

          t2 : AC <- MBR {읽은 데이터를 AC에 저장함}

        - STOR 명령어의 마이크로-연산 (**데이터의 저장**)

          t0 : MAR <- IR(addr) {값을 쓸 주소를 읽음}

          t1 : MBR <- AC {데이터 처리가 끝난 걸 MBR에 넣음}

          t2 : M[MAR] <- MBR {MBR에 있는 데이터가 버스를 타고 해당 기억장치에 값을 저장함.}

        - ADD 명령어의 마이크로-연산 (**데이터 처리**)

          t0 : MAR <- IR(addr) {값을 읽어 올 주소를 읽음}

          t1 : MBR <- M[MAR] {읽어 온 값을 MBR에 저장}

          t2 : AC <- AC + MBR {MBR에 저장 된 값을 AC와 더하여(덧셈 명령이므로) 저장. (산술을 위한 레지스터)}

        - JUMP 명령어의 마이크로-연산 (**프로그램 제어**)

          : 일반적으로 명령어들은 기억장치에 저장되어 있는 순서대로 실행함.

          ​	: 이때는 별도로 명령어의 실행 순서를 결정할 필요로 없음. PC에 의해 자동적으로 순서가 결정됨.

          : 하지만 전혀 다른 위치의 명령어를 실행해야 하는 경우도 있다. 

          : 현재 PC의 내용이 가리키는 위치가 아니라, <u>다른 위치의 명령어로 실행 순서를 바꾸도록</u> 해주는 명령어.

          : 이런 명령어를 **<u>분기(branch) 명령어</u>**라함.

          t0 : PC <- IR(addr) {오퍼랜드가 분기 목적지 주소를 가리킴.}

           : 실행 사이클에서는 그 주소를 PC로 적재만 하면 됨.

           : 다음 명령어 인출 사이클에서는 그 주소가 가리키는 기억 장소로부터 명령어가 인출됨. -> 명령어 실행 순서가 바뀜.

   2. 23 인터럽트 사이클

      - 인터럽트(interrupt) : 순차적인 명령어 실행을 중단. -> 다른 프로그램을 처리하도록 요구하는 매커니즘.

       : **긴급한 상황에 대처**하거나 <u>외부 장치들과의 상호작용</u>을 위하여 반드시 필요한 기능.

      ​	: 외부에서 인터럽트 요구가 들어올 경우, CPU는 원래의 **프로그램 수행을 중단**함.

      ​	: 요구된 **인터럽트를 처리해주기 위한 프로그램을 먼저 수행**.

      ​	: 이러한 프로그램을 인터럽트 서비스 루틴(interrupt service routine : ISR)이라 부름.

      - 인터럽트 사이클(interrupt cycle)

        1. 현재 PC의 내용(순차적으로 진행시 다음에 실행할 명령어의 주소)을 스택(stack)에 저장.

           : 인터럽트 처리를 완료 한 후에 복귀할 주소를 저장해두기 위한 절차.

        2.  해당 인터럽트 서비스 루틴 호출을 위해 그 루틴 시작 주소를 PC에 적재.

           : 이때 시작 주소는 인터럽트를 요구한 장치로 부터 전송되거나 미리 정해진 값으로 결정 됨.

        CPU가 인터럽트 사이클을 시작하기 전, <u>인터럽트가 가능한 상태로 세트 되어있는지</u> 확인되어야 한다.

        : 중요한 프로그램이 실행 중이여서 CPU가 인터럽트를 받지 못하도록 세트되어 있다면 인터럽트 사이클은 수행되지 않음.

        : 인터럽트 가능(Interrupt enabled) / 인터럽트 불가능(Interrupt disabled)는 CPU가 해당 명령어(El 혹은 Dl 명령어)를 수행하면서 변경시킬 수 있다.

        시작 -> 명령어 인출 -> 명령어 실행 -> 인터럽트가 가능한가? -> 인터럽트 검사 & 처리 -> goto 명령어 인출 -> 종료

        ​																예 : goto 인터럽트 검사 & 처리

        ​																아니오 : goto : 명령어 인출

        인터럽트 사이클, 마이크로-연산

        t0 : MBR <- PC {현재 PC에 저장된 값을 MBR에 저장함. PC가 덮어쓰기 전에!}

        t1 : MAR <- SP (스택 포인터의 위치를 MAR에 저장함. 왜? MBR데이터를 스택 메모리에 넣기 위하여)

        ​	 PC <- ISR	{인터럽트 루틴 시작 주소를 PC에 전달함.}

        t2 : M[MAR] <- MBR, {MBR에 저장된 값(정상 순서대로 프로그램 진행시, 다음 주소가 담긴 PC값.)}

        ​	 SP <- SP - 1 {맨 아래를 MBR로 채웠으므로, 스택 TOP은 그 위의 스택 메모리를 가리키게 됨.}

        

        인터럽트 사이클이 종료되어 다음 인출 사이클 시작시,

         : CPU는 인터럽트 서비스 루틴의 첫 번재 명령어부터 인출, 인터럽트 요구에 대한 처리를 시작함.

        : 인터럽트 서비스 루틴이 진행될 경우, 기존 명령어를 처리하면서 그 값이 AC에 남아있음.

        : 예를 들어 LOAD한 상황에서 인터럽트가 걸린 경우

        ​	: LOAD된 값은 AC에 남아있는데, 인터럽트 서비스 루틴에서 AC 레지스터를 사용한다면?

        ​	: 인터럽트 끝난 이후 원래 프로그램으로 돌아왔을 때 문제가 생김.

        : 따라서 인터럽트 서비스 루틴의 시작 단계에서 레지스터들의 내용을 스택에 저장함.

        : 루틴의 마지막 단계에서 복귀하기 직전에 그들을 복원(Restore) 시켜주는 절차가 필요함.

        

        다중 인터럽트(Multiple interrupt) : 인터럽트 서비스 루틴 중에 또 인터럽트 요구가 발생하는 경우.

        - 인터럽트 서비스 루틴 처리 도중에는 인터럽트 불가능 상태로 해버림.

          - 이후 처리가 끝나고 나서 가능 상태로 바뀌었을 때, 인식되고 처리함

        - 인터럽트 요구 간에 우선순위를 정함

          - 우선순위가 낮은 인터럽트 요구를 처리하는 중에 높은 인터럽트 요구가 들어올 경우

            : 현재의 인터럽트 서비스 루틴의 수행을 중단.

            : 새로운 인터럽트를 처리

            : 이 경우, main과 비슷하나, 복귀점이 main이 아니라 중단된 인터럽트. 

            (이후 이게 끝났을 때 main으로 가게 됨.)

   2. 2.4 간접 사이클(Indirect cycle)

      기억장치의 어떤 위치에 연산에 사용될 데이터의 주소가 저장 됨.

      명령어에 포함되어 있는 주소는 기억 장치의 어떤 위치를 가리킴.

      so, 어떤 위치의 기억장치를 읽음. 그 데이터에 있는 주소에 가서 다시 데이터를 읽음.

      : 인출 사이클과 실행 사이클에 위치하게 된다.

      : 명령어 내의 특정 비트(예를 들어 I비트)가 1로 세트된 경우에만 수행 된다.

      - 마이크로-연산

        t0 : MAR <- IR(addr) {명령어에 있는 주소를 MAR에 저장}

        t1 : MBR <- M[MAR] {M의 MAR에 가서 데이터(주소)를 MBR에 저장}

        t2 : IR(addr) <- MBR {t1에서 받아온 값을 IR의 주소 필드에 저장함.}

   2. 3 명령어 파이프라인

      명령어 파이프라인(**Instruction pipelining**) 

      : 명령어를 실행하는데 사용되는 하드웨어를 여러 개의 독립 단계들로 분리.

      : 동시에 서로 다른 명령어들을 처리하도록 함.

      ​	: CPU의 성능을 높여줌.

      : 분할 단계의 수가 많아질 수록 처리 속도가 높아지기 때문에,

      ​	: 최근에는 여러 개의 명령어 파이프 라인을 설치하기도 한다.

   2. 3.1 **2-단계 명령어 파이프라인**

      명령어를 실행하는 하드웨어를 인출 단계(fetch stage)와 실행 단계(execute stage), 두 개의 파이프라인으로 나눌 수 있다.

      하나의 클록 신호를 동시에 인가한다면? 동작 시간을 일치시킬 수 있다.

      : 즉 각 단계는 서로 다른 명령어에 대하여 각각의 동작을 수행할 수 있게 된다.

      t0 : 첫 번째 명령어를 인출한다.

      t1 : t0에서 인출된 명령어가 실행단계로 보내지고 실행함, 인출 단계는 두번째 명령어를 인출함.

      : 이렇게 다음에 실행 될 명령어를 미리 인출하는 것을 

      ​	: 명령어 선인출(Instruction prefetch) 혹은 인출 중복(fetch overlap)이라 한다.

      : 명령어 실행 하드 웨어를 두 단계로 분리시킨 것을 2-단계 명령어 파이프라인(two-stage instruction pipeline)이라고 부름.

      : 1단계 파이프 라인에서는 2클록이 지나야 명령어가 처리되지만,  

      : 2단계 파이프 라인에서는 첫 번째 명령어를 제외하고 한 클록씩 밖에 걸리지 않음.

      : 따라서 명령어가 많아질 수록 이론상 2배에 접근하게 됨.

      : 하지만 인출보다 실행의 소요 시간이 조금 더 김. -> 인출 후에 대기해야함. 

      ​	: 따라서 실제로는 두 배만큼 빨라지진 못함.

      3.2 **4단계 명령어 파이프라인**

      파이프라인 단계들의 처리 시간이 동일하지 않음 -> 더 걸리는 파이프라인 단계를 분할함.

      : 파이프 라인 단계의 수를 늘리면 속도 향상도 더 높아진다.

      : 따라서 2단계 파이프라인을 4단계로 분리함

      - 명령어 인출(IF) : 명령어를 기억장치로부터 인출함
      - 명령어 해독(ID) : 해독기(decoder)를 이용하여 명령어를 해석
      - 오퍼랜드 인출(OF) : 기억장치로부터 오퍼랜드를 인출
      - 실행(EX) : 지정된 연산을 수행, 결과를 저장.

      

      파이프 라인을 이용해 얻을 수 있는 속도 향상.

      T = k + (N - 1) {T는 전체 명령어 실행 시간, k는 파이프 라인 단계의 수, N은 실행할 명령어들의 수}

      : 첫번재 명령어를 실행할 때 k 주기가 걸림. 나머지 N - 1개들은 한 주기씩만 소요 됨.

      T = K * N (파이프 라인을 이용하지 않은 경우)

      Sp(속도 향상) = K * N / K + (N - 1)

      문제점 

      1. 4단계가 아닌 명령어도 있음. (어떤 명령어는 오퍼랜드를 인출하지 않기 때문.)

      but, 하드웨어를 단순화 시키기 위하여 OF를 수행하지 않더라도 4단계를 통괘해야 함. (불필한 시간 소모)

      2. 파이프라인 클록은 처리시간이 가장 오래 걸리는 단계가 기준.

         -> 슈퍼 파이프라이닝(Superpipelining) : 명령어 파이프라인의 단계들을 더욱 작게 분할하여 처리속도를 향상시킴.

      3. 메모리 충돌이 없다고 하더라도 OP단계와 IF 단계는 기억장치에 엑세스 해야함.

         : 엑세스가 동시에 발생할 수 없기 때문에 지연됨.

         -> 둘이 엑세스하는 내부 캐시(internal cache)를 명령어 캐시와 데이터 캐시로 분리

      4.  조건분기(conditional branch instruction)가 실행 될 경우, 

         미리 인출된 파이프라인에서 처리되던 명령어들이 무효화 됨.

         -> 분기 예측

         -> 분기 목적지 선인출

         -> 루프 버퍼

         -> 지연 분기를 사용

      상태 레지스터(Status register) :  조건 분기 명령어에서 사용하는 조건들이 저장된 곳. & 플래그를 모아둔 곳

      : 각 조건의 상태를 나타내는 비트를 플래그(flag)라고 부름.

      CPU는 실행 사이클 동안 조건 분기 명령어가 지정하는 플래그 값을 검사함

      : 분기 여부를 결정지음.

      - 일반적으로 상태 레지스터에 포함된 조건 플래그들
        - 부호 플래그
        - 제로 플래그
        - 올림수 플래그
        - 동등 플래그
        - 오버플로우 플래그
        - 인터럽트 플래그
        - 슈퍼바이저 플래그

      3.3 슈퍼스칼라(Superscalar)

      3.4 듀얼-코어 및 멀티-코어

      4 명령어 세트(Instruction set)

      CPU에 정의되어 있는 명령어들의 집합

      : 설계시 다음의 것들이 필요함.

      4.1 연산의 종류

      CPU가 수행할 수 있는 연산의 종류는 컴퓨터 마다 다양, 그중 가장 Basic한 것들.

      - 데이터 전송 : 레지스터끼리의, 기억장치끼리의 데이터를 이동하는 동작,

        : 기억장치 주소를 계산해야 하는 경우도 있다.

      - 산술 연산 : 정수 & 부동소수점에 대한 사칙연산

      - 논리 연산 : 각 비트들 간에 AND, OR, NOT 및 exclusive-OR 등 수행.

      - 입출력 : CPU <-> 외부 장치들 간 데이터 이동을 위한 동작들이 수행.

      - 프로그램 제어 : 명령어 실행 순서를 변경하는 연산.

        : 분기와 서브 루틴이 있다. 

        : 서브루틴 호출 시 필수 명령어,

        - CALL 명령어 : 서브 루틴을 호출(call)하는 명령어

        - RET 명령어 : 서브루틴으로부터 원래 프로그램으로 복귀(return)시키는 명령어

          CALL X 명령어에 대한 마이크로-연산

          t0 : MBR <- PC {현재 PC내용 MBR에 저장}

          t1 : MAR <- SP, PC <- X {스택 포인터를 MAR에 저장, PC에 호출할 X를 전달}

          t2 : M[MAR] <- MBR, SP <- SP - 1 {MBR(원래 PC내용)을 스택에 저장(M[MAR], 한 칸 스택 사용했기 때문에 조정}

          

          RET 명령어에 대한 마이크로 연산

          t0 : SP <- SP + 1 {스택에 저장된 복귀 주소를 가리킴}

          t1 : MAR <- SP {복귀 주소를 가리키는 데이터가 담긴 스택 포인터를 MAR에 저장}

          t2 : PC <- M[MAR] {MAR} {M[MAR]에 저장된 복귀 주소를 PC에 대입함.}

      4.2 명령어 형식

      - 연산 코드(Operation Code) : 수행할 연산을 지정해준다.

      - 오퍼랜드(Operand) : 연산을 수행하는데 필요한 데이터 혹은 데이터의 주소를 나타낸다.

        : 각 연산은 한 개 또는 두개의 입력 오퍼랜드들과 한 개의 결과 오퍼랜드를 가질 수 있다.

      - 다음 명령어 주소(Next Instruction Address) : 현재 명령어 실행이 완료된 후에

        : 다음 명령어를 인출할 위치를 나타냄.

        : 순차적으로 다음 명령어가 실행되는 경우에는 필요하지 않다.

        : 분기 혹은 호출 명령어와 같이 실행 순서를 변경하는 경우에 필요함.

      - 각 명령어는 일련의 비트들에 의해 표현된다.

        : 비트의 수는 위의 정보들을 나타내는 데 필요한 만큼 사용됨.

        : 명령어를 구성하는 비트들을 용도에 따라 몇 개의 필드(field)로 나눌 수 있다.

        - 명령어 형식(Instruction format) : 필드의 수와 배치 방식 및 각 필드에 포함되어 있는 비트 수를 정의한 것.

          : 명령어의 길이가 고정된 상태에서 어느 한 쪽 필드의 비트 수를 증가시키면 다른 필드의 비트 수는 그만큼 줄어듬.

          : 명령어를 구성하는 각 필드의 비트 수에 따라,

          ​	: 연산의 수 & 데이터의 표현 범위 & 주소 지정이 가능한 기억장치 영역이 결정 된다.
        
      - 명령어 형식 설계하기

        X =  (A + B) * (C - D)

        - 1-주소 명령어(one-address Instruction)

          ADD X;	 AC <- AC + M[X]

          : X는 데이터가 저장 된 기억장치를 말함.

          : 기억장치 X번지 내용과 누산기 (AC)내용을 더할 것, 그리고 그 결과를 AC에 저장

          : 명령어에 AC가 포함되어있으니 오퍼랜드는 기억 장치 하나만 포함하면 됨.

          : 따라서 더 넓은 영역의 주소들을 지정할 수 있다.

          LOAD A;	AC<- M[A]

          ADD B; AC <- AC + M[B]

          STOR T; M[T] <- AC

          LOAD C; AC <- M[C]

          SUB D; AC <- AC - M[D];

          MUL T; AC <- AC * M[T];

          STOR X; M[X] <- AC;

        - 2-주소 명령어(two-address Instruction)

          ADD R1, R2;	R1 <- R1 + R2

          : R1, R2 레지스터를 더하고 결과값을 레지스터 R1에 저장한다.

          ; 데이터가 저장된 레지스터들 중 하나에 연산 결과값을 저장함.

          ; 저장하는 레지스터는 덮어쓰기 됨. but 두 개의 오퍼랜드 필드만 있으면 됨.

          

          ADD R1, X;	R1 <- R1 + X

          : 오퍼랜드로 기억장치를 사용 가능.

          : but 주소지정 할 수 있는 기억장치 영역이 상당히 제한 됨.

          MOV R1, A;	R1 <- M[A];

          ADD R1, B;	R1 <- R1 + M[B];

          MOV R2, C;	M[C] <- R1;

          SUB R2, D;	R2 <- R2 - M[D]

          MUL R1, R2; R1 <- R1 * R2

          MOV X, R1; M[X] <- R1;

        - 3주소 명령어(three-address Instruction)

          ADD R1, R2, R3;	R1 <- R2 + R3

          : 세 개의 오퍼랜드들을 포함

          : 각각은 레지스터 번호 

        명령어에 포함되는 오퍼랜드 수에 따라 여러 가지 명령어 형식들이 존재할 수 있다.

        이러한 형식들은 프로그램 길이에 직접적인 영향을 미친다.

        ADD R1, A, B;	R1 <- M[A] + M[B];

        SUB R2, C, D;	R2 <- M[C] - M[D];

        MUL X, R1, R2;	M[X] <- R1 * R2;

      주소가 많은 명령어 형식일 수록, 프로그램 길이는 줄어든다.

      : 하지만 기억장치 용량은 별로 차이 없으며, 명령어 해독이 복잡해진다.

      4.3 주소지정 방식(Addressing mode)

      일반적으로 명령어 비트 수는 CPU가 처리하는 단어(Word)의 길이와 같도록 제한됨.

      제한된 수의 비트를 이용하여 가능한 다양한 방법으로 오퍼랜드를 지정하여 더 큰 용량의 기억장치를 사용할 방법

      - 기본적인 용어들

        - EA : 유효주소(Effective address) : 데이터가 저장된 기억장치의 실제 주소
        - A : 명령어 내의 주소 필드 내용(오퍼랜드가 기억장치 주소인 경우)
        - R : 명령어 내의 레지스터 번호(오퍼랜드가 레지스터 번호인 경우)
        - (A) : 기억장치 A번지의 내용
        - (R) : 기억장치 R의 내용

        명령어가 실행되는 과정에서 주소지정 방식에 따라 유효주소 EA가 결정됨.

        이때 EA는 실제 데이터를 읽어오기 위한 주소로 사용됨.

        주소지정방식이 복잡해질 수록 EA를 결정하는 데 걸리는 시간이 길어짐.

      1. 직접 주소지정 방식(Direct addressing mode)

         명령어 내 오퍼랜드 필드의 내용이 데이터의 유효주소로 사용되는 가장 간단한 방식

         EA = A;

         : 데이터 인출을 위해 한 번의 기억장치 엑세스만 필요하다.

         : 유효 결정을 위한 다른 절차나 계산이 필요하지 않다.

         : but 기억장치 주소 공간이 오퍼랜드 필드의 비트 수에 의해 제한됨.

      2. 간접 주소 지정 방식(Indirect addressing mode)

         명령어의 오퍼랜드 필드에 있는 기억장치 주소(A)에 유효주소를 저장해 둠.

         그러면, 최대 기억장치 용량이 그 기억장소에 담을 수 있는 비트 수로 결정 됨.

         EA = A; 혹은 EA = ((..(A)..)) {<u>여러 단계</u> 간접 주소 방식을 사용한 경우}

         이 방식을 사용할 경우, 플래그를 써야함.(플래그 I)

         I가 0인 경우 직접 주소지정 방식이고, I가 1인 경우 간접 주소 지정방식.

         실행 사이클 동안에 두 번의 기억장치 엑세스가 필요하다.

         1. 유효 주소를 읽어오기 위해
         2. 유효 주소에 접근하기 위해

      3. 묵시적 주소지정 방식(Implied addressing mode)

         데이터의 위치를 지정하지 않아도 이미 묵시적으로 정해짐.

         예를 들어 Shift 명령어의 경우, 누산기(AC)의 내용을 Shift함.

         오퍼랜드를 별도로 지정할 필요 없음. 자동적으로 AC에 대하여 결정.

      4. **즉시** 주소지정방식(Immediate addressing mode) (<u>즉시라 직접과 다름</u>)

         연산에 사용할 데이터가 명렁어 코드에 포함 됨.

         따라서 데이터 인출 과정이 필요하지 않다.

         레지스터나, 변수의 초기값을 어떤 상수 값으로 세트하는데 주로 사용 됨.

         : 기억장치 엑세스가 필요 없다는 게 장점

         : 사용할 수 있는 데이터의 크기가 오퍼랜드 필드의 비트 수에 의해 제한된다는 점이 단점.

      5. 레지스터 주소지정방식(Register addressing mode)

         연산에 사용될 데이터가 레지스터에 저장됨.

         : 따라서 오퍼랜드 필드의 내용은 레지스터 번호로 사용 됨.

         : 그 번호가 가리키는 레지스터 내용이 명령어 실행 과정에서 데이터로 사용 됨.

         EA = R

         : 레지스터의 수는 오퍼랜드 필드의 비트 수에 의해 결정 됨.

         : 명령어 형식에서 오퍼랜드의 비트 수가 적어도 됨. + 데이터 인출을 위해 기억장치 엑세스가 필요 없음.

         : 데이터 저장 위치가 CPU 내부 레지스터로 한정 됨.

      6. 레지스터 간점 주소지정 방식(Register-indirect addressing mode)

         EA = (R)

         오퍼랜드 필드가 가리키는 레지스터 내용이 유효 주소가 됨.

         따라서 레지스터 내용에 따라서, 기억장치 엑세스를 해야 함.

         주소를 저장하는 기억장치 영역은 레지스터 길이에 달려 있다.

      7. 변위 주소 방식(Displacement addrsesing mode)

         직접 주소지정 방식 + 레지스터 간접 주소지정 방식

         EA = A + (R)

         변위를 나타내는 주소 A와 레지스터 번호 R

         : EA는 R이 가리키는 레지스터 내용을 A와 더함으로서 결정됨.

         - 상대주소지정방식(Relative addressing mode) : 레지스터로 프로그램 카운터(PC)가 사용 됨.

           EA = A + PC

           : 현재 PC의 내용은 다음에 실행할 명령어의 주소

           : 변위는 그 명령어의 위치를 기준으로 한 상대적인 값

           : 분기 명령어를 실행할 때 사용함. (PC가 새로운 분기 목적지 주소로 갱신됨.)

           : 전체 기억장치 주소가 명령어에 포함되어야 함.

           : 일반적인 분기명령어보다 적은 수의 비트만 있으면 됨.

         - 인덱스 주소지정 방식(Indexing addressing model)

           EA = A + (IX)

           : A는 데이터 배열 시작 주소

           : 인덱스 레지스터는 A로부터의 각 데이터까지의 거리.

           : 루프시 인덱스 레지스터 내용을 증가 or 감소하면서 순차적으로 데이터 엑세스가 가능.

           ​	: 1씩 증감하는 것을 자동 인덱싱(auto-indexing)이라 함.

         - 베이스-레지스터 주소지정 방식(Base-register addressing mode)

           EA = A + (BR)

           기준이 되는 명령어의 주소가 저장 됨. -> 프로그램의 시작 위치를 지정하는데 사용.

           다중 프로그래밍에서 기억장치의 어던 위치에 저장되어 있는 프로그램들과 데이터를 다른 위치로 이동시켜야 하는 경우

           프로그램 내의 분기 명령어, 데이터 엑세스 명령어들의 주소 필드값도 이동된 후의 프로그램 및 데이터에 위치하도록 함.

           : but 베이스-레지스터 주소 지정 방식을 사용할 경우, 베이스 레지스터의 내용만 이동할 위치의 시작주소로 변경하면 됨.

      2.4.4 실제 상용 프로세서들의 명령어 형식

### 3. 산술과 논리연산

산술논리연산장치(Arithmetic and Logical) : 실제적으로 연산을 수행하는 하드웨어 모듈

 : 수치 및 논리 데이터에 대하여

- ALU의 내부 요소
  - 산술연산장치 : 산술연산들 (사칙연산)을 수행함.
  - 논리연산장치 : AND, OR, XOR, NOT 등을 수행
  - 시프트 레지스터(shift register) : 비트들을 좌측 또는 우측으로 이동시킴
  - 보수기 : 데이터에 대하여 2의 보수를 취한다. (음수화)
  - 상태 레지스터 : 연산 결과들을 나타내는 플래그(flag)들을 저장함.

: 레지스터 -> ALU로 입력됨.

: 결과는 레지스터들 중 하나에 저장됨.

: ALU는 연산 결과에 따라 상태 레지스터내 해당 플래그들을 세트.

: 해당 플래그들은 조건 분기 명령어 & 산술 명령어들에 의해 사용 됨.

: ALU 내외로의 데이터 이동을 제어하는 신호들은 제어 유니트로부터 제공됨.

: 입력 데이터에 대하여 연산을 수행할 내부 요소의 선택도 제어 유니트로부터 제공.



3. 2. 정수의 표현

      2진수 체계 (Binary number system) : 0과 1로 숫자를 표현함.

      : 이때 최하위 비트 a0 우측에 2진 소수점(Binary point)이 있다고 가정함 -> 고정소수점.

      - 부호 비트를 사용하는 2진수 표현
        - 부호화 크기 표현(Signed-magnitude representation)
        - 1의 보수 표현(1's complement representation)
        - 2의 보수 표현(2's complement representation)

      1. 부호화-크기 표현

         맨 좌측 비트를 부호 비트로 사용함

      2. 보수 표현(Complement representation)

         - 1의 보수 : 모든 비트들을 반전한다.

         - 2의 보수 : 모든 비트들을 반전한다. 결과값에 1을 더한다.

           : 1의 보수보다 갯수가 하나 더 많다.

      3.  부호 비트 확장

         - 부호화 크기 표현 :

         부호비트를 맨 좌측으로 이동시킴.

         - 보수 표현

         부호 비트와 같은 값으로 상위비트를 세트함.

   3.  논리 연산

      word 단위로 수행되는 산술 데이터와 달리, <u>비트 단위</u>로 의미를 가진다.

      : 연산 또한 **비트 단위**로 처리된다.

      - AND 연산
      - OR 연산
      - XOR 연산
      - NOT 연산
      - 선택적-세트 연산
      - 선택적-보수 연산
      - 마스크 연산
      - 삽입 연산

      - 비교 연산

        : 두 수를 XOR, 모든 비트가 0이면 Zero 플래그가 1로 셋팅 -> 같다. (Zero 플래그를 확인하면 됨.)

   4. 시프트 연산

      1. 논리적 시프트(logical shift) : 레지스터 내의 데이터 비트를 왼쪽 혹은 오른쪽으로 한 칸씩 이동시킴

         : 이때 시프트로 소실되는 최상위 비트, 최하위 비트는 버려짐.

         : 시프트 레지스터는 D플립-플롭으로 구성됨.

      2. 순환 시프트

         : 최상위, 최하위 비트를 버리지 않고 각각 맨 끝, 맨 앞으로 가게 함.

         : 직렬 데이터 전송(serial data transfer)이 가능하게 함.

      3. 산술 시프트(Arithmetic shift)

         부호-비트 확장(sign-bit extension)과 같은 결과를 얻게 해 준다.

      4. C 플래그를 포함한 시프트 연산

         : 좌측에 한 칸 더 Carry로 있음.Carry에서 좌측으로 시프트 하면 소실되고, 우측으로 시프트하면 최상위 비트가 부활

         : 순환시프트도 논리는 크게 다르지 않다.

   5. 정수의 산술 연산

      기본적인 산술 연산들

      - 보수화
      - 덧셈
      - 뺄셈
      - 곱셈
      - 나눗셈
      - 증가(increment) : 1증가
      - 감소(decrement) : 1감소

      1. 덧셈

         : 2의 보수 간의 덧셈에서 두 수를 더한 다음, 올림수가 발생하면 버린다.

         : 덧셈을 수행하는 하드웨어는 병렬 가산기(Parallel adder)이라 부른다.

         : 병렬 가산기는 데이터 비트 수 만큼의 전가산기(Full-adder)으로 구성된다.

         : 덧셈 결과가 범위를 초과하게 되어, 결과값이 틀린 경우, 오버플로우(Overflow)라 부른다.

         이때, 오버플로우는, 최상위 비트와 차상위비트의 XOR를 수행하여 검출할 수 잇다.

         V = C8 ^ C7

      2. 뺄셈

         감수를 (빼는 값) 음수화 하여 더한다.

         : 마찬가지로 올림수는 버려진다.

         : 보수기(Complementer을 사용함.)

      3. 곱셈

         : M 레지스터에 피 승수, Q 레지스터에 승수를 각각 작성. A 레지스터(합)와 C 레지스터(캐리)를 0

         A와 Q 레지스터를 직렬 연결 (0000 - q3,q2,q1,q0)

         Q0가 1인 경우

         : A레지스터에 M 레지스터를 더함. 이후 오른쪽으로 시프트. 이때, 올림수는 A의 최상위 비트로 들어옴.

         ​	: 올림수는 A 레지스터와 M 레지스터의 합을 구할 때 발생함.

         Q0가 0인 경우

         : 오른쪽으로 한 비트씩 시프트함.

         Q의 비트 길이만큼 시프트가 끝났을 때 계산을 종료함.

         - 2의 보수간 곱셈

           : Booth 알고리즘을 사용.

           곱셈의 경우에서 Q-1을 추가함.

           (0000 - q3,q2,q1,q0 - q-1)

           q0와 q1이 같은 경우 -> 아무것도 하지 않음.

           q0와 q1이 ^관계인 경우 -> M을 더함.

           이후, 양쪽의 경우에 대하여 A-Q-Q1의 산술적 우측 시프트함.

      4. 나눗셈

         제수는 M 레지스터에, 피 제수는 A와 Q 레지스터에 저장 [A-Q]

         A-Q 레지스터를 좌측으로 한 비트씩 시프트.

         [환원의 경우] A에 -M을 더한 후 부호가 같으면 냅두고, 아니면 뺌

         [환원이 아닌 경우] 그냥 뺀 값을 A가 가지고 있음.

          : 만약 양수가 나올 경우 그 자리 몫1, 아닌 경우 0

          : 그리고 마지막에 M 더하기 전 A를 가져옴.

      5. 부동 소수점

         : 지수 * 가수

         : 바이어스 127, 지수 - 127값 - 최소가 -126 (IEE 754

         : 바이어스 128, 지수 - 128값 - 최소가 -128

         32비트의 경우, 부호비트 1, 지수비트 8, 가수비트 23

         이떄, 가수는 1.M(1은 히든 비트라 부름) 단, 지수가 0인 경우, 0.M으로 판단함.

         64비트의 경우, 부호비트 1, 지수비트 11, 가수비트 52

         : 지수 바이어스 1023

         - 부동 소수점 산술 연산

           - 덧셈 뺼셈의 경우, 지수를 같아지도록 조정 -> 가수간 덧셈 & 뺄셈 -> 정규화

           - 곱셈, 나눗셈의 경우, 가수끼리 곱하거나 나눔 

             : 곱셈의 경우는 지수끼리 더함, 나눗셈의 경우는 지수끼리 뺌.

             : 정규화